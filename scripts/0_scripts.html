<html> <head>
<title>Scripts for crossing minimization: format translations, runs, statistics</title>
</head>

<body>
<h2 align="center">Scripts for crossing minimization: format translations, runs, statistics</h2>

<pre>
</pre>
<h3>Files in lexicographic order</h3>
<hr>
<ul>
<li>
<strong><a href="channelDegrees.py">channelDegrees.py</a> --</strong><br>
<pre>
channelDegrees.py - takes an sgf file and prints statistics about degrees
of nodes relative to the upper and lower layers of each channel
</pre>
</li>
<hr><br>
<li>
<strong><a href="collectParetoPoints.py">collectParetoPoints.py</a> --</strong><br>
<pre>
collectParetoPoints.py - designed to gather multiple Pareto points into a
  single Pareto list; it's a simple filter (for now)

 input is a sequence of lines of the form (Pareto output from min_crossings)
   x1^y1;x2^y2;...
 output has one Pareto point per line - format is tab separated
</pre>
</li>
<hr><br>
<li>
<strong><a href="createConnectedDagClass">createConnectedDagClass</a> --</strong><br>
<pre>
based on a profile that specifies the number of nodes, edges, and layers,
as well as a skew factor that determines both the maximum degree and the
variance in number of nodes per layer.
Note: leaves a file called stats.out in the class directory
</pre>
</li>
<hr><br>
<li>
<strong><a href="createDag">createDag</a> --</strong><br>
<pre>
createDag - creates a dag randomly using the scheme devised for the
 InfoVis poster paper; Uses layeredDag.awk and layeredDagOrd.awk
These dags are also the "uniform" dags in the 2012 paper
</pre>
</li>
<hr><br>
<li>
<strong><a href="createMSTClass">createMSTClass</a> --</strong><br>
<pre>
createMSTClass - a script for creating a class of random dags which are
derived from one of the types used in MST experiments). Number of
nodes can vary widely within a class, but density and number of layers
appear to be roughly the same.
The idea is to create a random graph with specific characteristics
(from MST-Experiments) and do layer assignment for it.
</pre>
</li>
<hr><br>
<li>
<strong><a href="createRandomClass">createRandomClass</a> --</strong><br>
<pre>
a script for creating a class of random dags for which
both the variance in layer width and the variance in degree can be
carefully controlled. The latter may require some experimentation using the
imported createRandomLayeredGraph.py script.
</pre>
</li>
<hr><br>
<li>
<strong><a href="createRandomLayeredGraph.py">createRandomLayeredGraph.py</a> --</strong><br>
<pre>
createRandomLayeredGraph.py - offers a mechanism for producing layered
 graphs with different variances with respect to number of nodes per layer
 and degrees of nodes. Output is in sgf format, which can be converted to
 dot or graphml, as desired. Graphs have high probability of being connected
 (and interesting) because minimum degree of a node is 2.
</pre>
</li>
<hr><br>
<li>
<strong><a href="createUniformDagClass">createUniformDagClass</a> --</strong><br>
<pre>
a script for creating a class of random dags based on a profile that
specifies the number of nodes on each layer and on the probability
of an edge.  A settable number (size) of dot/ord file pairs are
generated; uses createDag
</pre>
</li>
<hr><br>
<li>
<strong><a href="dot+ord2layered_graphml">dot+ord2layered_graphml</a> --</strong><br>
<pre>
dot+ord2layered_graphml - creates a graphml file from a dot and an ord file
Uses dot_and_ord_to_sgf in ../src
</pre>
</li>
<hr><br>
<li>
<strong><a href="dot+ord2sgf">dot+ord2sgf</a> --</strong><br>
<pre>
dot+ord2sgf - creates an sgf file from a dot and an ord file
Uses dot_and_ord_to_sgf in ../src
</pre>
</li>
<hr><br>
<li>
<strong><a href="dot2sgf">dot2sgf</a> --</strong><br>
<pre>
converts from dot format to a truncated version of
(s)imple (g)raph (f)ormat described in the script.
 Usage: dot2sgf base_name
  converts base_name.dot to base_name.sgf
Requires extract-dot-graph.awk and sgfDirect.awk
</pre>
</li>
<hr><br>
<li>
<strong><a href="followHeuristic">followHeuristic</a> --</strong><br>
<pre>
run one heuristic followed by another
arguments to min_crossings are hard-wired for specific experiments
and can be changed by editing the first few lines of the script
</pre>
</li>
<hr><br>
<li>
<strong><a href="followHeuristicRR">followHeuristicRR</a> --</strong><br>
<pre>
a variant of followHeuristic in which both heuristics are randomized
</pre>
</li>
<hr><br>
<li>
<strong><a href="followHeuristicR_">followHeuristicR_</a> --</strong><br>
<pre>
a variant of followHeuristic that randomizes the first heuristic
</pre>
</li>
<hr><br>
<li>
<strong><a href="followHeuristic_R">followHeuristic_R</a> --</strong><br>
<pre>
a variant of followHeuristic in which the second heuristic is randomized
</pre>
</li>
<hr><br>
<li>
<strong><a href="forExcel">forExcel</a> --</strong><br>
<pre>
a script that creates a csv file based on results of experiments on
a specified collection of heuristics (as identified by
suffixes). The script can be edited to include more columns, but
currently there is a column called Name, which lists the names of
graphs on which the heuristics have been run and a column for each
heuristic, giving the minimum number of crossings achieved.
</pre>
</li>
<hr><br>
<li>
<strong><a href="gph2dot">gph2dot</a> --</strong><br>
<pre>
 converts a gph file, one arising from the generation mechanism for minimum
 spanning tree (MST) experiments into a dot file for a generic directed acyclic graph;
 used by createMSTClass
</pre>
</li>
<hr><br>
<li>
<strong><a href="gph2dot+ord">gph2dot+ord</a> --</strong><br>
<pre>
gph2dot+ord - converts a gph file (from the MST experiments) to dot and ord
files for use with crossing minimization programs.
Scripts and programs that are used as intermediaries are:
gph2dot (to get a simple dot file with edges directed from lower to higher
numbered nodes), java LayerAssignment to assign layers and create a dot and
ord file with dummy nodes (this must be in the current CLASSPATH!).
</pre>
</li>
<hr><br>
<li>
<strong><a href="gph2layered_graphml">gph2layered_graphml</a> --</strong><br>
<pre>
converts a gph file (from the MST experiments) to a graphml
file that represents a layered graph; see sgf2layered_graphml for more details.
Scripts and programs that are used as intermediaries are:
 - gph2dot (to get a simple dot file with edges directed from lower to higher
            numbered nodes),
 - java LayerAssignment to assign layers and create a dot and
         ord file with dummy nodes (this must be in the current CLASSPATH!), and
 - dot+ord2graphml, which in turn uses dot_and_ord_to_sgf, an executable in
         the src directory (compiled from a C program).
</pre>
</li>
<hr><br>
<li>
<strong><a href="graphml2dot.py">graphml2dot.py</a> --</strong><br>
<pre>
converts a simple dialect of graphml (the one currently produced by Galant)
 to the dot notation used for GraphViz.
See https://github.com/mfms-ncsu/galant for more information about
Galant (Graph Algorithm Animation Tool)
</pre>
</li>
<hr><br>
<li>
<strong><a href="graphml2sgf">graphml2sgf</a> --</strong><br>
<pre>
converts from standard graphml
to the (s)imple (g)raph (f)ormat described below.
</pre>
</li>
<hr><br>
<li>
<strong><a href="lff2sgf.py">lff2sgf.py</a> --</strong><br>
<pre>
 Translates from (l)ayer (f)irst (f)ormat (for lack of a better name),
 used in recent papers, such as
 Martí, R., Campos, V., Hoff, A., Peiró, J.,
  "Heuristics for the min–max arc crossing problem in graphs."
  in Expert Systems with Applications 109, 100 – 113.
 and files downloaded from
 https://grafo.etsii.urjc.es/optsicom/mmacp/mmacpfiles/MinMaxGDPlib.zip

The lff format begins with a line of the form
  NUMBER_NODES NUMBER_OF_EDGES NUMBER_OF_LAYERS
The second line lists the number of nodes on each layer, starting with the "bottom"
(or "left" based on figures in the Martí et al. paper).
All edges are directed from earlier layers to later ones, not that this matters.

Each subsequent line has two integers, the endpoints of an edge.
Node numbers for these edges are implicit from the number of nodes on the layers.
For example, if the second line in the file is.
 2 3 4
then nodes 1 and 2 are on layer 1, nodes 3-5 on layer 2 and nodes 6-9 on layer 3.

sgf format is described in, among others, mlcm2sgf.py
IMPORTANT: The minimization program in src assumes layers are numbered starting at 0.

Usage: lff2sgf INPUT_FILE > OUTPUT_FILE
</pre>
</li>
<hr><br>
<li>
<strong><a href="makeIsoClass">makeIsoClass</a> --</strong><br>
<pre>
makeIsoClass - a simple script for creating a class of orderings,
                the original order plus 32 random permutations, of each layer
                from a given .ord file
</pre>
</li>
<hr><br>
<li>
<strong><a href="mlcm2dot+ord">mlcm2dot+ord</a> --</strong><br>
<pre>
creates both a dot and ord file from an mlcm file
Uses mlcm2sgf.py, sgf2dot.awk, and sgf2ord.awk
</pre>
</li>
<hr><br>
<li>
<strong><a href="mlcm2sgf.py">mlcm2sgf.py</a> --</strong><br>
<pre>
  translates from mlcm format, as documented at
   http://www-lehre.informatik.uni-osnabrueck.de/theoinf/index/research/mlcm
  and described in the script, to sgf format, also described in the script.
</pre>
</li>
<hr><br>
<li>
<strong><a href="mvsed">mvsed</a> --</strong><br>
<pre>
 utility to rename files according to a pattern substitution
  (not clear where this originated)
</pre>
<li>
<strong><a href="ralay.py">ralay.py</a> --</strong><br>
<pre>
ralay.py - offers a mechanism for producing layered graphs with
different variances with respect to number of nodes per layer, number of
dummy nodes, degrees of nodes, shapes, etc.. Output is in sgf format, which
can be converted to dot or graphml, as desired. Graphs are guaranteed to be
connected (and interesting) because each node has indegree 1 (unless on layer 0)
and outdegree 1 (unless on the highest layer).
</pre>
</li>
<hr><br>
</li>
<hr><br>
<li>
<strong><a href="randomizeClass">randomizeClass</a> --</strong><br>
<pre>
a script that creates a single isomorph (scrambled version) of every instance
 in a given directory
</pre>
</li>
<hr><br>
<li>
<strong><a href="randomizeHeuristics">randomizeHeuristics</a> --</strong><br>
<pre>
randomizeHeuristics - run one heuristic followed by another heuristic on a
single instance of a problem; do this in four ways:
 (i) randomize neither
 (ii) randomize the first but not the second
 (iii) randomize the second but not the first
 (iv) randomize both
In each case, there will be NUMBER_OF_RUNS runs done, each with different
random seeds. The results will be stored in four files called
instance-h1+h2-xy, where instance is the name of the problem instance, h1
and h2 are the two heuristics, x is whether or not the first heuristic is
randomized - indicated by _ or R, and y the same for the second.
</pre>
</li>
<hr><br>
<li>
<strong><a href="runHeuristic">runHeuristic</a> --</strong><br>
<pre>
run the min_crossings program with specific command-line arguments
 on instances a directory containing .dot and .ord files
</pre>
</li>
<hr><br>
<li>
<strong><a href="runHeuristicR">runHeuristicR</a> --</strong><br>
<pre>
run the min_crossings program with specific command-line arguments
on instances in a directory containing .dot and .ord files; this version runs
the heuristics in random mode using a different seed for each instance.
Caution: the rand_seq program must be in the src directory,
         do 'make rand_seq' there
</pre>
</li>
<hr><br>
<li>
<strong><a href="scrambleSgf.py">scrambleSgf.py</a> --</strong><br>
<pre>
Randomly permutes nodes and edges of an sgf file;
order in which nodes appear and their position in a layer are permuted independently
</pre>
</li>
<hr><br>
<li>
<strong><a href="sgf2dot+ord.py">sgf2dot+ord.py</a> --</strong><br>
<pre>
translates from sgf format, described in the script, into a .dot file
and an .ord file, whose formats are described with the sbg_software at
http://people.engr.ncsu.edu/mfms/Software/SBG_Software/formats.html
</pre>
</li>
<hr><br>
<li>
<strong><a href="sgf2layered_graphml.py">sgf2layered_graphml.py</a> --</strong><br>
<pre>
 translates from sgf format, described in the script, to the graphml format
 used by Galant. This program is a simple filter, translating from
 standard input to standard output.
</pre>
</li>
<hr><br>
<li>
<strong><a href="sgf2lff.py">sgf2lff.py</a> --</strong><br>
<pre>
Translates from sgf format to lff format.
These formats are described in mlcm2sgf.py and lff2sgf.py, respectively.
</pre>
</li>
<hr><br>
<li>
<strong><a href="sugi-gml2sgf">sugi-gml2sgf</a> --</strong><br>
<pre>
converts from gml (simpler than graphml) to sgf
 both formats are described in the script
</pre>
</li>
<hr><br>
</ul>
<address>
<a href="http://people.engr.ncsu.edu/mfms/">Matthias F. (Matt) Stallmann</a><br>
Created: Mon Dec 21 12:08:20 EST 2020
</address>
</body> </html>
